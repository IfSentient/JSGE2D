<html>
	<head>
		<title>Test</title>
		<script type="text/javascript" src="Common.js"></script>
		<script type="text/javascript" src="Sprite.js"></script>
		<script type="text/javascript" src="TileSet.js"></script>
		<script type="text/javascript" src="CollisionBlock.js"></script>
		<script type="text/javascript" src="SceneObject.js"></script>
		<script type="text/javascript" src="SceneObserver.js"></script>
		<script type="text/javascript" src="CollisionObserver.js"></script>
		<script type="text/javascript" src="InputHandler.js"></script>
		<script type="text/javascript" src="Scene.js"></script>
		<script type="text/javascript" src="PhysicsObject.js"></script>
		<script type="text/javascript" src="TileObject.js"></script>
		<script type="text/javascript" src="Controller.js"></script>
		<script type="text/javascript" src="InputController.js"></script>
		<script type="text/javascript" src="Actor.js"></script>
		<script type="text/javascript" src="Viewport.js"></script>
	</head>
	<body style="margin: 0px; padding: 0px; scrolling: none;">
		<canvas id="canvas" width="500" height="500"></canvas>
		<script type="text/javascript" >
			//Initializing the canvas
			var canvas = document.getElementById("canvas");
			var context = canvas.getContext("2d");
			
			//Canvas dimensions
			var W = window.innerWidth; 
			var H = window.innerHeight;
			
			canvas.style.width = W;
			canvas.style.height = H;
			context.canvas.width = W;
			context.canvas.height = H;
			
			var spr = new Sprite({
				src:'Test Resources/triceratops.png',
			});
			spr.addAnimation({
				name : 'WalkLeft',
				startX : 0,
				startY : 0,
				width : 78,
				height : 40,
				padding : 0,
				frames : 8,
				speed : 3
			});
			spr.addAnimation({
				name : 'WalkRight',
				startX : 0,
				startY : 40,
				width : 78,
				height : 40,
				padding : 0,
				frames : 8,
				speed : 3
			});
			spr.setState({state : 'WalkLeft'});
			spr.pauseAnimation();
			
			var c = new CollisionBlock({
				width: 78,
				height: 37,
				matrix: [[0],[0,1,1,0]]
			});
			
			var a = new Actor({
				x: 10,
				y: 70,
				z: 0,
				yAcceleration: 30,
				sprite: spr,
				collisionBlock: c
			});
			
			a.addState({
				name: 'StartWalkLeft',
				spriteState: {state:'WalkLeft'},
				xAcceleration: -50
			});
			a.addState({
				name: 'StartWalkRight',
				spriteState: {state:'WalkRight'},
				xAcceleration: 50
			});
			a.addState({
				name: 'WalkLeft',
				spriteState: {state:'WalkLeft'},
			});
			a.addState({
				name: 'WalkRight',
				spriteState: {state:'WalkRight'},
			});
			a.addState({
				name: 'StopWalkLeft',
				xAcceleration: 50
			});
			a.addState({
				name: 'StopWalkRight',
				xAcceleration: -50
			});
			a.addState({
				name: 'Still',
				spritePause: true,
				xVelocity: 0
			});
			a.addState({
				name: 'Jump',
				spritePause: true,
				yVelocity: -50
			});
			a.addState({
				name: 'FreeFall',
				spritePause: true
			});
			a.setState('FreeFall');
			
			var ts = new TileSet({
				src: 'Test Resources/tileset.png',
				tileWidth: 32,
				tilesPerRow: 16,
				rows: 13,
				cols: 64
			});
			
			ts.setLayer({
				zIndex: 0,
				layer:
				[
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[1,1,1,1,1,1,1,1,1,1,8,8,1,1,1,1,1,1,1,1,1,1,8,8,1,1,1,1,1,1,1,1,1,1],
					[2,2,2,2,2,2,2,2,2,2,8,8,2,2,2,2,2,2,2,2,2,2,8,8,2,2,2,2,2,2,2,2,2,2]
				]
			});
			
			var scene = new Scene({
				width: W,
				height: H,
				tileset: ts
			});
			
			scene.addSceneObject(a);
			
			//the function for the update method of our InputController is the same regardless of input. 
			//Really, one should extend the InputController class (or modify it) with their own movement state code in the update() function.
			var movementStateFunction = function(args) {
				var a = args.object;
				if(a.y_vel < 4 && a.y_vel > -4) { //if we're jumping or falling, we obviously can't actually walk anywhere or come to a stop
					if(args.stateObject.walking_left) {
						if(a.getState() !== 'WalkLeft' && a.getState() !== 'StartWalkLeft') a.setState('StartWalkLeft');
						if(a.getState() === 'StartWalkLeft' && a.x_vel < -20) a.setState('WalkLeft');
					} else if(args.stateObject.walking_right) {
						if(a.getState() !== 'WalkRight' && a.getState() !== 'StartWalkRight') a.setState('StartWalkRight');
						if(a.getState() === 'StartWalkRight' && a.x_vel > 20) a.setState('WalkRight');
					} else {
						if(a.getState() === 'WalkLeft' || a.getState() === 'StartWalkLeft') a.setState('StopWalkLeft');
						if(a.getState() === 'WalkRight' || a.getState() === 'StartWalkRight') a.setState('StopWalkRight');
						if(a.getState() === 'StopWalkLeft' && a.x_vel >= 0) { a.x_vel = 0; a.setState('Still'); }
						if(a.getState() === 'StopWalkRight' && a.x_vel <= 0) { a.x_vel = 0; a.setState('Still'); }
					}
				}
				if(a.getState() == 'Jump') a.setState('FreeFall');
			}
			
			var ih = new InputHandler();
			var ic = new InputController();
			ih.registerController(ic);
			a.addController(ic);
			ic.addInputBinding({
				type: 'keydown',
				keyCode: 65,
				action: function(args) {
					args.stateObject.walking_left = true;
					args.stateObject.update = movementStateFunction;
				}
			});
			ic.addInputBinding({
				type: 'keydown',
				keyCode: 68,
				action: function(args) {
					args.stateObject.walking_right = true;
					args.stateObject.update = movementStateFunction;
				}
			});
			ic.addInputBinding({
				type: 'keyup',
				keyCode: 65,
				action: function(args) {
					args.stateObject.walking_left = false;
					args.stateObject.update = movementStateFunction;
				}
			});
			ic.addInputBinding({
				type: 'keyup',
				keyCode: 68,
				action: function(args) {
					args.stateObject.walking_right = false;
					args.stateObject.update = movementStateFunction;
				}
			});
			ic.addInputBinding({
				type: 'keydown',
				keyCode: 32,
				action: function(args) {
					var a = args.object;
					if(a.getState() !== 'FreeFall' && a.getState() !== 'Jump') a.setState('Jump');
					args.stateObject.update = movementStateFunction;
				}
			});
			
			var c2 = new CollisionBlock({
				width: 320,
				height: 32,
				matrix: [[1]]
			});
			
			var to1 = new TileObject({
				x: 0,
				y: 352,
				z: 0,
				collisionBlock: c2
			});
			var to2 = new TileObject({
				x: 384,
				y: 352,
				z: 0,
				collisionBlock: c2
			});
			var to3 = new TileObject({
				x: 768,
				y: 352,
				z: 0,
				collisionBlock: c2
			});
			scene.addSceneObject(to1);
			scene.addSceneObject(to2);
			scene.addSceneObject(to3);
			
			//In order for the Dino Actor to actually stop when it hits the floor, we need something to tell it that it hit the floor.
			//For this, we use a CollisionObserver object and register all SceneObjects which may collide.
			var observer = new CollisionObserver();
			observer.registerObject(a);
			observer.registerObject(to1);
			observer.registerObject(to2);
			observer.registerObject(to3);
			scene.addObserver(observer);
			
			var OffscreenObserver = SceneObserver.extend();
			OffscreenObserver.prototype.update = function(args) {
				for(var i=0; i<this.scene_objects.length; i++) {
					var so = this.scene_objects[i];
					if(so.x < -2 * so.width || so.x > scene.width || so.y < 0 || so.y > scene.height) { so.setState('FreeFall'); so.x = 10; so.y = 10; so.x_acc = 0; so.x_vel = 0; so.y_vel = 0; }
				}
			}
			
			var oso = new OffscreenObserver();
			oso.registerObject(a);
			scene.addObserver(oso);
			
			var CatchUpViewport = Viewport.extend();
			CatchUpViewport.update = function(args) {
				var vpx = this.x;
				Viewport.prototype.update.call(this,args);
				if(vpx == this.x && this.target !== undefined) {
					var x_mid = Math.floor(target.x + (this.target.width / 2)) + Math.floor(this.width / 2);
					var y_mid = Math.floor(target.y + (this.target.height / 2));
					if(this.x > x_mid) {
						this.x -= 5;
						if(this.x < x_mid) this.x = x_mid;
					}
					else if(this.x < x_mid) {
						this.x += 5;
						if(this.x > x_mid) this.x = x_mid;
					}
				}
			}
			
			var vp = new CatchUpViewport({
				width: 300,
				height: 200,
				//xBuffer: 20,
				drawX: 500,
				target: a
			});
			vp.center();
			
			scene.addViewport(vp);
			
			function draw() {
				scene.update({ms:33});
				scene.draw({context:context});
			}
			
			//draw();
			window.setInterval(draw, 33);
			
			//Never do this. This is just because Ihaven't finished implementing this behaviour at this point
			document.addEventListener('keydown', function(evt) {
				 ih.keyDown(evt);
			});
			document.addEventListener('keyup', function(evt) {
				ih.keyUp(evt); 
			});
		</script>
	</body>
</html>